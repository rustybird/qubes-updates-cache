        qubes-updates-cache, a Squid-based package update cache

Updating my various templates was getting a little annoying with all the
redundant network traffic, so I set up a qubes-updates-cache modeled on
qubes-updates-proxy, using standalone Squid (no Apache etc. involved).


        Security considerations

1. For Tor users, the remote network has some insight about what's installed
   on the same physical computer, because there is no Tor circuit isolation
   between update requests from different clients. This can be prevented by
   waiting at least 10 minutes (or sending NEWNYM) between updating different
   clients. (The same is true of qubes-updates-proxy.)
2. The remote network can distinguish if a file is requested via qubes-updates-
   cache (Squid) or via qubes-updates-proxy (tinyproxy). The former's user base
   is smaller, making attacks (where valid signatures for malicious packages
   can be produced somehow) more targeted even over Tor, i.e. less likely to be
   detected.
3. Clients can DOS each other's package updaters by poisoning the cache with
   bogus updates, because qubes-updates-cache's deduplication makes no attempt
   to verify that a file is requested from a server that's in an official
   mirror rotation.
4. Clients can determine if a package is installed on another client on the
   same physical computer by requesting it and measuring cache response time.
5. Preferably, qubes-updates-cache should be hosted on a separate ProxyVM only
   used by templates, not by template-based VMs: Otherwise, the only thing that
   prevents template-based VMs (which are more likely to be compromised than
   the templates themselves) from also launching attacks (3) and (4) is the
   firewall rule denying access to the updates proxy port; but the Qubes
   firewall is not designed to be a reliable security mechanism.


        Installation

Create a new ProxyVM, which currently should be based on Fedora 23 (minimal is
okay), ensure it has a netvm, and enable the qubes-updates-cache service:

    [dom0] $ qvm-create --proxy --label red --template fedora-23-clone-2 squidp
    [dom0] $ qvm-prefs --set squidp netvm default  # or sys-whonix etc.
    [dom0] $ qvm-service squidp --enable qubes-updates-cache

Copy this directory (containing the README you're reading) into your new
ProxyVM's template, carefully inspect its contents there and:

    [fedora-23-clone-2] # dnf install squid
    [fedora-23-clone-2] # ./install
    [fedora-23-clone-2] # poweroff

Make your new ProxyVM the netvm for each of the clients whose package updates
you want to cache (in this example, a Whonix workstation template), and ensure
connections to the updates cache (which uses the same IP:port as the non-
caching updates proxy) are allowed:

    [dom0] $ qvm-prefs --set whonix-ws netvm squidp
    [dom0] $ qvm-firewall whonix-ws --yum-proxy allow

Finally, for Whonix gateway/workstation clients, you currently need to bypass
the safety mechanism that checks for a torified update proxy:

    [dom0] $ qvm-service whonix-ws --enable whonix-secure-proxy

That's it! Up to 4 GiB of package updates will be cached to squidp's volatile
storage in /var/lib/qubes/vm-updates/. If you want to keep them across reboots,
use /rw/config/rc.local, or /rw/config/qubes-bind-dirs.d/ in Qubes 3.2, to bind
mount a directory in /rw/ owned by squid:squid to that destination. (The
qubes-updates-cache systemd service starts after these hooks have finished.)
